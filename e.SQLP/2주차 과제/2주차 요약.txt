
 0. 인덱스 스캔 효율
    (인.비.스.범.같.이.선)
   
 1. 인덱스 매칭도
     - 점조건/ 선조건
     - Check조건/ Driving조건  

    ※ 결합 인덱스 우선순위 결정
       .항상(자주) 사용되는 가?
       ."="조건
       .Cardinality(분포도)
       .소트연산 대체

 2. 인덱스 선행컬럼이 등치(=) 조건이 아닐 때 발생하는 비효율

     <CASE_1>
    [인덱스: 아파트시세코드+평형+평형타입+인터넷매물]
    SELECT *
        FROM 매물아파트매매
      WHERE 아파트시세코드 = '1105'
          AND 평형                  = '25'
          AND 평형타입            = 'C'
          AND 인터넷매물 BETWEEN '1' AND '2'  
       ORDER BY 입력일 DESC;

       . 선행컬럼이 모두= 조건일때 필요한 범위만 스캔

     <CASE_2>
    [인덱스: 인터넷매물+아파트시세코드+평형+평형타입]
    SELECT *
        FROM 매물아파트매매
      WHERE 아파트시세코드 = '1105'  -- Check 조건
          AND 평형                  = '25'
          AND 평형타입            = 'C'
          AND 인터넷매물 BETWEEN '1' AND '2'    -- Driving 조건
       ORDER BY 입력일 DESC;

       . 인덱스 선두 컬럼 인터넷매물이 between 조건
       . 아파트시세코드를 만족하는 레코드가 인터넷 매물 값(0,1,2,3)별로 흩어져 있다.
       . 조건을 만족하지 않는 레코드까지 스캔 후 버리는 비효율


 3. Between 조건을 IN-LIST로 변경 했을 때 인덱스 스캔 효율

    [주의사항]
    . IN-LIST 개수가 많지 않아야 한다.
    . 수직적 탐색이 IN-LIST 횟수 만큼 발생
    . 수평적 스캔의 비효율 보다 수직적 탐색에 대한 비효율이 더 클 수 있으며
    . 인덱스 높이(Height)가 높을때 비효율 증가

    ※ IN-LIST가 많을 경우Leaf Block의 비효율이 더 효율적일 수 있다.
    ※ 수직적탐색-> Random Access
    ※ 수평적 스캔-<Sequential Access


 4. Index Skip Scan울 이용한 비효율 해소

   <CASE_1>
    [인덱스: 판매구분+판매월]
    -- Index Range Scan (블록I/O cr=281)
       SELECT COUNT(*)
           FROM 월별고객별판매집계  T
         WHERE  판매구분 = 'A' 
             AND   판매월 BETWEEN '200801' AND '200812'

     
   <CASE_2>
    [인덱스: 판매월+판매구분]
   
    -- BETWEEN (블록I/O cr=3090)
       SELECT COUNT(*)
           FROM 월별고객별판매집계  T
         WHERE  판매구분 = 'A' 
             AND   판매월 BETWEEN '200801' AND '200812'

   -- IN-LIST  (블록I/O cr=314)
       SELECT COUNT(*) 
           FROM 월별고객별판매집계  T
         WHERE  판매구분 = 'A' 
             AND   판매월 IN ('200801','200802','200803','200804','200805','200806',
                                      '200807','200808','200809','200810','200811','200812')   
          
   -- Index Skip Scan  (블록I/O cr=300)
       SELECT /*+ INDEX_SS(T 월별고객별판매집계_IDX2) */ 
                    COUNT(*) 
           FROM 월별고객별판매집계  T
         WHERE  판매구분 = 'A' 
             AND   판매월 BETWEEN '200801','200812'

   => 수직적 참색이 많은 IN-LIST 보다 Index Skip Scan 이 근소하게 유리


 5. 범위검색 조건을 남용할 때 발생하는 비효율
  
    [인덱스: 상품코드+주문일자+주문유형]

    -- 주문일자 조건이 있을 경우
    SELECT 상품코드, 주문일자, 주문유형, ...
       FROM 주문
     WHERE 상품코드 = :PROD_CD       -- P120
         AND 주문일자 = :ORDER_DT      -- 20170102 <=========== 주문일자 조건이 있을 경우
         AND 주문유형 = :ORDER_TYPE  -- 2
     
     -> 주문일자가 조건에 포함될 경우 비효율 zero

    -- 주문일자 조건이 없을 경우
    SELECT 상품코드, 주문일자, 주문유형, ...
       FROM 주문
     WHERE 상품코드 = :PROD_CD       -- P120
         AND 주문유형 = :ORDER_TYPE  -- 2
     
     -> 주문일자가 조건에 포함될 경우 비효율 발생

    -- 주문일자 LIKE 검색
    SELECT 상품코드, 주문일자, 주문유형, ...
       FROM 주문
     WHERE 상품코드 = :PROD_CD                     -- P120
         AND 주문일자 LIKE :ORDER_DT || '%'     -- 20170102 <========== 주문일자 조건을 Like로 처리
         AND 주문유형 = :ORDER_TYPE  -- Check 조건

     -> 비효율 발생

   ===> SQL 분기 필요

    SELECT 상품코드, 주문일자, 주문유형, ...
       FROM 주문
     WHERE :ORDER_DT IS NOT NULL  -- 주문일자(x)  :ORDER_DT(o)
         AND 상품코드 = :PROD_CD       
         AND 주문일자 = :ORDER_DT      
         AND 주문유형 = :ORDER_TYPE  
    UNION ALL
     WHERE :ORDER_DT IS NULL  -- 주문일자(x)  :ORDER_DT(o)
         AND 상품코드 = :PROD_CD       
         AND 주문유형 = :ORDER_TYPE  
   
     -> 주문일자가 조건에 포함될 경우 비효율 zero
         주문일자가 조건에 포함되지 않을 경우 어쩔 수 없이 비효율 발생


    ☞☞ 주문일자 칼럼이 Not Null 일 경우 SQL 단순화 가능
    -> OR Expand 활용

    SELECT 상품코드, 주문일자, 주문유형, ...
       FROM 주문
     WHERE 상품코드 = :PROD_CD       
         AND 주문일자 = NVL(:ORDER_DT, 주문일자)      
         AND 주문유형 = :ORDER_TYPE  
  

 6. 같은 컬럼에 두 개의 버위검색 조건 사용 시 주의 사항

    <CASE_1>
      SELECT *
         FROM 교재
       WHERE 번호 <= 10000  <-- 드라이빙 조건
           AND 번호 <= 10;

     -> Predicate Information
         2 - access("번호<=10000)
              filter("번호"<=10)

    <CASE_2>
      SELECT *
         FROM 교재
       WHERE trim(번호) <= 10000  <-- 드라이빙 조건
           AND 번호 <= 10;

     -> Predicate Information
         2 - access("번호<=10)


7. Between과 Like 스캔 범위 비교

   - between을 사용하는 것이 정확한 방식이나, 개발자들의 편이에 의해 like 사용
   - between을 사용하면 성능적으로 손해볼 것은 없다.
   
   ※ like가 '=' 및 between 보다 비효율

 
8. 인덱스 스캔 효율
   - 최근 데이터를 주로 읽을 때: 인덱스 : 종료일자 + 시작일자
   - 과거 데이터를 주로 읽을 때: 인덱스 : 시작일자 + 종료일자
   - 인덱스 수정 불가한 상황 : Index_Desc 힌트
   - 중간 지점을 읽을 때
     -> 어떠한 인덱스 든 비효율이 발생하지만 rownum <= 1 조건 활용

9. Unbalanced Index 
   - B-tree의 B는 Balanced
   - B-Tree 인덱스에서 우측과 같은 현상은 발생하지 않음
  
10. Index Skew 
   - 대량 삭제 후 발생 현상
   - 빈 블록은 free-list로 등록되지만 반환하지 않음
   - 재사용 가능하나 다시 채워 질 때까지 인덱스 스캔효율 저하   

11. Index Sparse
   - 대량의 삭제 작업 후 발생
   - 인덱스의 밀도가 낮은 상황
   - Skew 현상과 같이 완전히 빈 블록은 재 사용되지만,
   - 동 현상은 Empty Block이 거의 없어 데이터가 채워질 때까지 인덱스 비효율 발생
   - 총 레코드 건수가 일정한데도 인덱스 공간 사용량 지속 증가는 주로 동 현상이다.

12. 인덱스 재성성 요건
   - 인덱스 분할에 의한 경합이 현저히 높을 때
   - 자주 사용되는 인덱스 스캔 효율을 높이고자 할 때. 특히 NL Join에서 반복 액세스되는 인덱스 높이
     (Height)가 증가했을 때
   - 대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
   - 총 레코드 수가 일정한데도 인덱스가 계속 커질 때
   ※ 인덱스 재생성은 작업의 부하로 위와 같이 확실한 효과가 예상될 때만 시행하는 것이 바람직

13. 비트맵 인덱스
   - Distinct Value 개수가 적을 때
   - 적은 용량을 차지하므로 인덱스가 여러 개 필요한 대용량 테이블에 유용
   - 다양한 분석관점(Dimension)을 가진 팩트성 테이블에 주로 사용

   - 단독으로 쓰임새는 없으나
   - 여러 비트맵 인덱스를 동시 활용시 대용량 데이터 검색 성능 향상에 효과
   - DML 부하 과다 -> 정형화되지 않은 임의 질의(ad-hoc query) 환경에 많이 사용 (DW)

14.  함수기반 인덱스
    <사용예>
    select * from 주문
    where nvl(주문수량,0) < 100;

    create index emp_x01 on 주문(nvl(주문수량, 0));

    - 주문 수량이 null 인 레코드에 0으로 채워진 인덱스 생성
    - 대소문자를 구분해서 입력 받은 데이터를 대,소문자 구분 없이 조회 할 때 흔히 사용

   - 데이터 입력, 수정시 함수를 적용해야 하기에 다소 부하 발생 가능
   - 사용된 함수가 User-Defined 함수일 경우 부하 극심
   - 남용하지 말고 꼭 필요한 경우 활용 필요

15 . 리버스 인덱스
  - 일련번호, 주문일시 등의 멀럼에 인덱스를 만들 경우
    .입력되는 값이 순차적 증가로 리프 블록에만 데이터가 적재
    . Right Growing 현상
  - Insert가 심할 때 인덱스 블록 경합으로초당 트랜잭션 처리량 감소
  - 입력된 값을 거꾸로 변환해서 저장->데이터 고르게 분포
  - equal(=) 검색만 가능하며, 부등호, between, like 등의 범위 검색 조건에 사용 불가

16. Nested Loop 조인
  - Outer Table(=Driving Table)
  - Inner Table(=Lookup Table)
 
  - Random Access 위주의 조인 방식
  - 조인을 한 레코드씩 순차적으로 진행
  - 대용량 처리시 치명적인 한계점 발생
  - 인덱스 구성 전략이 매우 중요
  - 온라인 트랜잭션 환경에 적합
  
  ※ Look-up 테이블의 조인 칼럼은 반드시 인덱스 필요
 
17. Sort merge 조인-1
 - 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬
 - 머지 단계: 정렬된 양쪽 집합을 merge
 - 조인을 위해 실시간으로 인덱스를 생성하는 것과 같은 효과
 - 양쪽 집합을 정렬 후 NL 조인과 같은 방식으로 진행
 - PGA 영역에서 처리로 빠른 속도
 - 소트 부하만 감수한다면 버퍼 캐시에서 조인하는 NL 조인보다 유리
 - 조인 컬럼에 인덱스 유무와 상관 없음

18. Sort merge 조인-2
 - 조인 하기 전에 양쪽 집합을 정령
 - 부분적으로, 부분범위 처리가 가능
 - 테이블별 검색 조건에 의해 전체 일량이 좌우된다
 - 스캔위주의 방식

 - 효율적인 활용
   . First 테이블에 소트 연산을 대체할 인덱스가 있을 때
   . 조인할 First 집합이 이미 정령되어 있을 때
   . 조인 조건식이 등치 조건이 아닐 때 (해시조인은 등치(=) 조건만 사용 가능)

19. Hash 조인-1
 - 두개의 테이블 중 작은 집합을 읽어 Hash Area에 적재 (Build Input)
 - 반대쪽 큰 집합을 읽어 해시 테이블을 탐색(probe Input)
 - 해시 테이블을 탐색할 때 해시 함수를 사용
 - 등치(=) 조건만 사용 가능

 - NL 조인 처럼 Random 액세스 부하 없음
 - 소트머지 조인처럼 소트부하도 없음
 - 단, Build Input이 Hash Area 크기 안에 들어가는 것이 성능의 성패를 좌우한다.
 - NL 조인은 Inner 쪽 테이블 버퍼 캐시 탐색을 위해 래치를 획득하지만, 해시조인은 래치 획득과정이
   없는 PGA에서 처리하는 바, 빠른 탐색 과정

20. Hash 조인-2  
 - 한쪽 테이블이 Hash Area에 담길 정도로 충분히 작아야 함
 - Build Input 해시 키 컬럼에 중복 값이 거의 없어야 함

 - 조인 컬럼에 적당한 인덱스가 없어 NL 조인이 비효율 적일 때
 - 조인 컬럼에 인덱스가 있더라고 NL조인 드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많아
    Random 엑세스 부하가 심할 때
 - 소트머지 조인하기에는 두 테이블이 너무 커 소트 부하가 심할 때
 - 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인 할 때

21. Hash 조인 실행 계획-등호형
 - 첨부자료 참고

22. Hash 조인 실행 계획-계단형
 - 첨부자료 참고

23. 조인 순서의 중요성
 
 [Sort Merge 조인의 순서]
  -Disk sort 가 필요한 경우        : 큰 테이블 Driving이 유리 (Disk I/O 회수 감소 유도)
  -PGA Sort Area 안에 담길 경우: 적은 테이블 Driving이 유리 (Join 회수 감소)
 
 
    

   

   
 

            
